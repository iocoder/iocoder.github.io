<html>
    <head>
        <title>
            Why Computer Scientists Beat Computer Engineers
        </title>
        <link rel="stylesheet" type="text/css" href="../css/style.css">
    </head>
    <body>
        <table width="100%">
            <tr>
                <td>
                    <img width="200px" src="../img/flag.jpg" alt="O Canada!" />
                </td>
                <td width="200px">
                    <iframe src="./address.html" seamless></iframe>
                </td>
            </tr>
        </table>
        <h1 class="title">
            Why Computer Scientists Beat Computer Engineers
        </h1>
        <h4 class="date">
            Feb 4th, 2018
        </h4>
        <p>
            What I like about this piece that I have just written is that it is very
            judgemental and over-generalizing. It's pretty cool
            to ignore everything about the great, diverse population
            from which engineers come, and claim that all engineers
            have some very specific traits. Human mind loves generalization
            and categorization, and I am just writing this one
            to please my mind.
        </p>
        <table class="figure">
            <tr>
                <td>
                    <img src="../img/ceguy.jpg" width="300px" />
                </td>
                <td>
                    <img src="../img/csgirl.jpg" width="250px" />
                </td>
            </tr>
            <tr>
                <td>
                    Computer engineer: WOW it finally prints Hello World! I am a genius!
                </td>
                <td>
                    A computer scientist from 1980s repairing her Apple machine to do
                    her research in Artificial Intelligence.
                </td>
            </tr>
        </table>
        <h2 class="subtitle">
            Computer Scientisits are <u>Geek</u>,
            Computer Engineers are <u>Wannabe Geek</u>
        </h2>
        <p>
            You can see this simple fact in every CS school and every CE school.
            A typical CS-student computer will simply have GNU/Linux or probably FreeBSD. They
            might even go further and use other UNIX(-Like) systems. Now ask one of those
            Computer Engineering students to show you their laptop. The argument for
            Microsoft Windows is always ready: Proteus/Multisim/Autocad/Whatever doesn't
            work on Linux (Yes they don't know the correct name, GNU/Linux).
        </p>
        <table class="figure">
            <tr>
                <td>
                    <img src="../img/desktop.png" width="640px" />
                </td>
            </tr>
            <tr>
                <td>
                    My desktop at some point of time.
                </td>
            </tr>
        </table>
        <p>
        </p>
        <h2 class="subtitle">
            Theoretical Computer Science Reshapes Your Mind
        </h2>
        <p>
           The study of Theoretical Computer Science (TCS) is something that
           strongly differentiates between a scientist and a dumb engineer.
           It is magic. A CS undergraduate student is expected to have courses
           in
           <a href="https://en.wikipedia.org/wiki/Discrete_mathematics"
              target="blank">Discrete Mathematics</a>,
           <a href="https://en.wikipedia.org/wiki/Symbolic_logic"
              target="blank">Symbolic Logic</a>,
           <a href="https://en.wikipedia.org/wiki/Switching_theory"
              target="blank">Switching Theory</a>
           (i.e,
           <a href="https://en.wikipedia.org/wiki/Logic_synthesis"
              target="blank">Digital Logic</a>),
           <a href="https://en.wikipedia.org/wiki/Automata_theory"
              target="blank">Automata Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Formal_language"
              target="blank">Formal Languages Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Computability_theory"
              target="blank">Computability Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory"
              target="blank">Computational Complexity Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Information_theory"
              target="blank">Information Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Operating_systems"
              target="blank">Operating Systems</a>,
           <a href="https://en.wikipedia.org/wiki/Artificial_intelligence"
              target="blank">Artificial Intelligence</a>,
           <a href="https://en.wikipedia.org/wiki/Data_mining"
              target="blank">Data Mining</a>, and
           <a href="https://en.wikipedia.org/wiki/Programming_language_theory"
              target="blank">Programming Language Theory</a>.
           This nice collection of topics really opens your mind.
           <b>You become smarter</b>. You gain a deep understanding of
           <span style="color: green">what a computation is</span>,
           and <span style="color: green">what the limits of a computer are</span>.
           These two green points are actually what Computer Science tries to
           answer.
        </p>
        <table class="figure">
            <tr>
                <td>
                    <img src="../img/amused.jpg" width="500px" />
                </td>
            </tr>
            <tr>
                <td>
                    A CS student amused in her first Linear Algebra lecture.
                </td>
            </tr>
        </table>
        <p>
            Computer engineers keep claiming that they are the ones who understand
            the difference between hardware and software, how hardware and software
            interact, and how to codesign software with hardware.
            <b>This is not true</b>. First of all, the study of
            <a href="https://en.wikipedia.org/wiki/Computer_architecture"
               target="blank">Computer Architecture</a>,
            which is considered as the core field of Computer Engineering, first originated
            in CS schools, not Engineering schools!
        </p>
        <p>
            Modeling a computer processor and abstracting it into
            <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture"
               target="blank">Instruction Set Architecture</a>
            (ISA) is a pure CS method of abstracting computing machines into abstract
            automata! Even
            if we talk about
            <a href="https://en.wikipedia.org/wiki/Computer_organization"
               target="blank">Computer Organization</a>
            and how to design
            the components of the machine, the copulative study of
            <a href="https://en.wikipedia.org/wiki/Switching_circuit_theory"
               target="blank">Switching Circuit Theory</a>
            and
            <a href="https://en.wikipedia.org/wiki/Finite-state_machine"
               target="blank">Finite Automata Theory</a>
            is purely Computer Science.
            I bet 99% of CS schools offer such courses.
        </p>

        <p>
            After you study the typical mathematical model of a computer processor,
            which is a finite state machine, you are expected to combine the processor
            with a limited form of a computer memory, and abstract them both into a
            <a href="https://en.wikipedia.org/wiki/Pushdown_automaton"
               target="blank">Push-down automaton</a> model,
            then you study
            <a href="https://en.wikipedia.org/wiki/Turing_machine"
               target="blank">Turing Machine</a> model with an infinite tape,
            and see how we can simulate any computer program in the world using
            a Universal Turing Machine. Here you know the theoretical power and
            limitations of the computer you have designed, and you go
            further by studying
            <a href="https://en.wikipedia.org/wiki/Computability"
               target="blank">Computability</a>
            and
            <a href="https://en.wikipedia.org/wiki/Decidability_(logic)"
               target="blank">Decidability</a>.
            You learn to reduce Turing Machine into models that encorporate
            the concept of
            <a href="https://en.wikipedia.org/wiki/Processor_register"
               target="blank">computer register</a>,
            like
            <a href="https://en.wikipedia.org/wiki/Register_machine"
               target="blank">Register machines</a>
            and
            <a href="https://en.wikipedia.org/wiki/Random-access_machine"
               target="blank">RAM machine</a> (Harvard Architecture!).
        </p>
        <table class="figure">
            <tr>
                <td align="right">
                    <img src="../img/qsort1.png" height="350px" />
                </td>
                <td align="left">
                    <img src="../img/qsort2.png" height="350px" />
                </td>
            </tr>
            <tr>
                <td colspan="2">
                    One of my computational complexity theory course lectures at
                    school, by Prof.
                    <a href="https://scholar.google.ca/citations?user=DlSX_XcAAAAJ&hl=en"
                       target="blank">Amr Elmasry</a>
                    <br />
                    (hand-written by my colleague,
                    Hanan Ahmad). <b>This is Computer Science</b>.
                </td>
            </tr>
        </table>
        <p>
            The poor Computer Engineering schools really lack this connection
            (<span style="color: green; font-weight: bold;">from
            Digital Design and Computer Architecture to Theory of
            Computation</span>).
            They just teach you that there is something called
            Finite State Machine, and it consists of circles and arrows! (LOL!)
            Then you can use them to create sequential logic, then
            to design a processor control unit, either hard-wired or programmable,
            as well as ALU, pipeline, exceptions, and other structures.
            And that's it. They claim they know where the hardware and software
            meet, but the reality is: they never know!
        </p>
        <p>
            And the reason why they do not know where they meet is simple:
            If they did study Computer Science, they would know that any
            kind of logic that solves a computable problem (i.e, any Turing machine)
            can be implemented using either software (i.e, those symbols on the tape
            of the Turing Machine!), or Hardware (any model of computation
            whose power is lower than or equal to Turing Machine, can
            be simulated by a Turing Machine!)
        </p>
        <table class="figure">
            <tr>
                <td>
                    <img src="../img/oncomp.png" width="600px" />
                </td>
            </tr>
            <tr>
                <td colspan="2">
                    <a href="../pdf/oncomp.pdf"
                       target="blank">On Computable Numbers, with an Application to the
                                      Entscheidungsproblem<a/>.
                    <br />
                    By
                    <a href="https://en.wikipedia.org/wiki/Alan_Turing"
                       target="blank">Alan Turing</a>,
                    1936. This is the point of time when CS was born.
                    <br />
                    (Ignore everything you have seen on that Enigma-focused
                     movie because it
                    <br />
                     has nothing to do with the real research
                     work done by the mathematician).
                </td>
            </tr>
        </table>
        <h2 class="subtitle">
            Tell me More About Low-Level Programming
        </h1>
        <p>
            Computer Engineers will claim everywhere that they are the
            masters of low-level programming. The reality is, they are rather the masters
            of
            <a href="https://en.wikipedia.org/wiki/Spaghetti_code"
               target="blank">Spaghetti Programming.</a>
        </p>
        <p>
            When we started learning programming at university, it was
            an 'art' course, not science. <b>PROGRAMMING IS AN ART</b>.
            Furthermore, the programming textbook that any computer scientist
            must have been exposed to at least once in their life is
            clearly called <b>'The Art of Computer Programming'</b> (TAOCP)
            by the mathematician
            <a href="https://en.wikipedia.org/wiki/Donald_Knuth"
               target="blank">Donald Knuth</a>. Guess what? The code
            samples in this CS-core book is in
            <a href="https://en.wikipedia.org/wiki/Assembly_language"
               target="blank">Assembly Language</a>. I am not saying 'CS-core'
            because of the main topic of the textbook (which is programming),
            but actually because of the content which basically encorporates
            <a href="https://en.wikipedia.org/wiki/Data_structure"
               target="blank">Data Structures</a>
            and
            <a href="https://en.wikipedia.org/wiki/Algorithm"
               target="blank">Algorithms</a>,
            i.e. topics where Engineers are very very poor.
        </p>
        <p>
            In any CS school, there are basic set of system-software-related courses that
            most CS majors must take:
        </p>
        <ul>
            <li>
                <u><b>Computer Organization</b></u>:
                <br />
                <br />
                The course name is misleading. It doesn't mean Computer Organization
                in the sense of 'hardware microarchitecture,' but instead it is
                just an entry-level course to a more advanced course on
                Computer Architecture. In this course we've studied what
                an ISA is, the debatable difference between computer organization and
                computer architecture, <b>68K processor and its instruction set</b>,
                <b>sample 68K assembly-code programs</b>, how the assembled
                program is stored in RAM and executed by 68K, various I/O devices
                of the computer and system bus, serial and parallel
                communication protocols, computer memory: SRAM and DRAM, signals between
                processor and memory, the hardware and software of the hard disk,
                the printer, computer screen and VGA adapter, keyboard and typewriters,
                etc...
            </li>
            <table class="figure">
                <tr>
                    <td>
                        <img src="../img/partial.png" width="800px" />
                    </td>
                </tr>
                <tr>
                    <td>
                        Partial address decoding example, from Principles
                        of Computer Hardware, Clements.
                    </td>
                </tr>
            </table>
            <br />
            <li>
                <u><b>Systems and Components Programming</b></u>:
                <br />
                <br />
                This course is core in many CS schools, while some other schools will offer it
                as a highly-recommended elective course. Students learn the
                theory of assembly language as a foundational
                <a href="https://en.wikipedia.org/wiki/Imperative_programming"
                   target="blank">imperative-class programming language</a>.
                You learn concepts like mnemonics, operand structures and addressing
                modes, directives, opcode vs extended mnemonics, code sections,
                and other interesting low-level programming details (studied
                in an academic, concrete course). Next you learn how the
                assembler works, and
                <b>students design a two-pass assembler</b>.
                <br />
                <br />
                Next, you learn
                how linkers and loaders work, and
                <b>students design a linker-loader for the object code generated
                   by the assembler they have designed</b>.
                Furthermore, you learn macros and macro processing, and
                <b>students design a macro processor</b>.
                Finally, the students integrate all those tools
                in one <b>integrated development environment</b> where
                the user simply creates assembly-code modules, then
                the modules automatically get macro-processed, assembled, and
                linked!
            </li>
            <br />
            <table class="figure">
                <tr>
                    <td>
                        <img src="../img/gnuld.png" width="800px" />
                    </td>
                </tr>
                <tr>
                    <td>
                        GNU linker manual pages on my gay communist machine.
                    </td>
                </tr>
            </table>
            <br />
            <li>
                <u><b>Operating Systems</b></u>:
                <br />
                <br />
                A basic course in any (and absolutely any) Computer Science curriculum.
                In the afore-mentioned systems programming course you have designed
                a set of tools that translate the assembly program into static or relocatble
                object code ready to be loaded into memory, and you designed
                the loader program itself. Now is the time to learn how to manage
                several program contexts loaded in memory simultaneously. You will
                be introduced to the concepts of <b>process</b>,
                <b>thread</b>, <b>context switching</b>, <b>multiprogramming</b>,
                and <b>scheduling</b>.
                You will study synchronization techniques
                like <b>Semaphores</b> and <b>Monitors</b>. Next,
                <b>students design</b> (or complete the design of) <b>an OS that
                   does nothing but loads programs in memory and schedule
                   them for the processor</b>.
                <br />
                <br />
                Next, you learn how the operating system manages I/O devices
                and you will be introduced to concepts like
                <b>Device Drivers</b>, <b>Interrupt Requests</b>, <b>Kernel-Mode</b>
                and <b>User-Mode</b> execution. You have the option
                to embed all the drivers and modules into one concrete program
                (<b>Monolithic Kernel</b>) or to execute device drivers
                and modules in user-mode (<b>Microkernel</b>).
                <br />
                You will also be exposed to concepts like <b>Memory Protection</b>,
                <b>Memory Management</b>, and algorithms that allocate the memory
                dynamically for the running programs, like
                <b><a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation"
                   target="blank">Buddy Algorithm</b></a>.
                <br />
                <br />
                Finally you study <b>file systems</b> and concepts like
                <b>inode-structures</b> vs <b>FAT</b> and hard-disk sector-based
                buffering and scheduling. I bet every CS graduate knows what
                I am talking about.
            </li>
            <br />
            <table class="figure">
                <tr>
                    <td>
                        <img src="../img/diningph.png" width="400px" />
                    </td>
                </tr>
                <tr>
                    <td>
                        Every CS major knows what this is. From Operating Systems Internals
                        an Design Principles, Stallings.
                    </td>
                </tr>
            </table>
            <br />
            <li>
                <u><b>Programming Language Theory</b></u>:
                <br />
                <br />
                As a follow-up to Systems Programming course, it's important to show
                our open-minded CS students that imperative programming is not
                everything! There are way many programming paradigms that
                they must be aware of. The two biggest classes for programming languages
                are called <b>Imperative Languages</b> and <b>Declarative Language</b>.
                In imperative languages, you describe the control flow of the program,
                while a declarative-program focuses on the intention of the computation
                and the data flow, <b>without describing the control flow</b>.
                <br />
                <br />
                Under imperative-language class we find <b>procedural languages</b>,
                where a program is divided into a set of procedures that call
                each others. Concepts like <b>block</b> and <b>scope</b>
                differentiate the procedural languages from other
                imperative languages.
                Under imperative-language class we also find <b>modular languages</b>
                where a program is organized as a set of modules that interact
                with each other, and each module has an <b>interface</b>.
                <br />
                <br />
                Finally, we develop an interesting imperative subclass called
                <b>structured languages</b>, where the control flow consists
                of three basic elements: imperative sequence, if-conditioned
                block, and while-looped blocked. Any other structure
                (like for loop) is simply reduced to these three basic blocks.
                <b>Object Oriented Programming</b>
                is usually taught in a separate academic course, however,
                in this course a CS student should be able to understand how
                different OOP concepts are from structured programming.
                <br />
                <br />
                In contrast to imperative programming, there is a huge class
                that is called declarative programming. In declarative languages,
                you do not describe the control flow at all. Interesting
                subclasses are <b>logic programming languages</b> (Prolog!),
                <b>functional programming languages</b> (everywhere, from
                Haskell to Python's lambda expressions!), and finally
                <b>data-flow languages</b> (VHDL and Verilog).
                Parallel programming is a direct application to declarative
                programming (where Ada language and its little child, VHDL, rock).
                <br />
                <br />
                The reason why I am mentioning this pure-CS course is to
                <b>let the ignorant engineers know that they know nothing
                   about VHDL and Verilog</b>. We, as computer scientists,
                can tell you how different HDLs are from other
                languages, and how to express a computation using an HDL
                language vs. how it is done in imperative languages.
                Finally, we can show you the mathematical proof that
                the VHDL and Verilog are Turing-complete. You guys think
                that we do not do VHDL and Verilog. However, we
                actually know them better than you do! actually
                we designed them for you!
            </li>
            <br />
            <table class="figure">
                <tr>
                    <td>
                        <img src="../img/ada.jpg" width="300px" />
                    </td>
                </tr>
                <tr>
                    <td>
                        Ada Lovelace, the first computer programmer in history.
                        <br />
                        The brilliant Ada programming language is named after her.
                    </td>
                </tr>
            </table>
            <br />
            <li>
                <u><b>Compilers</b></u>:
                <br />
                <br />
                Finally, you study the most advanced level of system software, compilers.
                And the reason why I am saying 'most advanced' is that you need
                to study theory of computation and the afore-mentioned courses first.
                Compilers and Programming Language Translators course is usually
                offered in the last year of a BSc in Computer Science program.
                <br />
                <br />
                It's mind blowing how formal language theory and theory of computation
                are two different labels for the same logical entity.
                Every model of computation has an equivalent
                subclass of <b>recursively-enumerable languages</b>.
                A <b>Finite State Machine</b> is simply
                an acceptor that tells you whether the input
                word belongs to the language or not (that's why when you studied
                switching circuits and models of computation courses, you have
                been taught that an FSM tuple has a a set element called (final states)).
                <br />
                <br />
                A <b>language</b> (set of words) can be expressed by two models:
                <ol>
                    <li>
                        <b>Automaton</b> (acceptor), from theory
                        of computation domain. This is the program that tells us whether
                        a word belongs to the language or not (The C compiler!); and
                    </li>
                    <li>
                        <b>Grammar</b> (generator), from formal language theory domain.
                        This is the recursive-generator for all the words in the language
                        (The C Standard!).
                    </li>
                </ol>
                <br />
                A <b>regular language</b> is a language that can be expressed by
                a <b>regular expression</b>. A regular expression is a mathematical
                structure that describes recursive application of
                <b>concatenation</b>, <b>alternation</b>,
                and <b>Kleen closure</b> operations on <b>empty sets</b>,
                <b>sets of empty strings</b>, or <b>sets of language symbols</b>.
                <b>Kleene Theorem</b> tells us that for every <b>Finite State Machine</b>
                automaton, there is a corresponding regular language that the
                automaton accepts (recognizes). Poor computer engineering students
                do not know that the <b>sequence detectors</b> they designed
                in digital logic courses are a form of such recognizers. Similar
                to the fact that a finite state machine is an acceptor/recognizer
                for a regular language, A
                <b>regular grammar</b> is a generator for a regular language.
                <br />
                <br />
                <table class="figure">
                    <tr>
                        <td>
                            <img src="../img/langs.png" width="800px" />
                        </td>
                    </tr>
                    <tr>
                        <td>
                            Language classes and their corresponding grammars (generators)
                            and automata (acceptors).
                        </td>
                    </tr>
                </table>
                <br />
                The main application for the study of regular languages is the
                <b>lexical analysis</b> phase of the compiler, which is the
                very first phase of compilation process.
                Every <b>lexeme</b> type of the programming language
                might constitue a regular language by itself. For instance, when
                computer engineers study CS 101, they are taught that a variable
                name should only consist of letters, numbers, and underscores, and
                it can't start with numbers (why? the poor engineers will never know
                why a variable name shouldn't start with a number).
                A CS student interprets this as the following: an <b>identifier</b>
                is a word that belongs to the regular language expressed
                by the following regular expression:
                <code>({a-z}|{A-Z}|{_}).({a-z}|{A-Z}|{0-9}|{_})*</code>
                <br />
                <br />
                The <b>lexical analyser</b> is simply a collection of acceptors
                for all kinds of lexemes (regular identifiers, regular float
                <b>literals</b>, <b>keywords</b>, etc...) encorporated in the
                <b>source language</b>. It's a big FSM that
                consists of sub-FSMs for every regular language the
                input text might encorporate. A CS student designs
                a <b>lexical analyser generator</b>, which
                takes a set of (lexeme type, corresponding regular expressions)
                ordered pairs as input, and generates the lexical analyser (i.e. the big FSM)
                as output (<b>Yeah, the output of this program is another program</b>).
                The lexical analyser (the output program itself) takes
                arbitrary text as input,
                and outputs the lexical structure of the text (the lexemes found
                and their types).
                <br />
                <br />
                <ul>
                    <li>
                        Example for input to lexical analyser generator:
                        <br />
                        <code>
                            (open_brkt, {(})
                            <br />
                            (close_brkt, {)})
                            <br />
                            (if_keyword, {i}.{f})
                            <br />
                            (op, {<}|{>}|{=})
                            <br />
                            (identifier, ({a-z}|{A-Z}|{_}).({a-z}|{A-Z}|{0-9}|{_})*)
                            <br />
                            (integer_literal, {0-9}.{0-9}*.({L}|lambda))
                        </code>
                    </li>
                    <br />
                    <li>
                        The output of the generator is another program, called,
                        for instance, <code>lexer.elf</code>.
                    </li>
                    <br />
                    <li>
                        Example for text input to <code>lexer.elf</code>:
                        <br />
                        <code>if (var123 = 5)</code>
                    </li>
                    <br />
                    <li>
                        The corresponding output of <code>lexer.elf</code>:
                        <br />
                        <code>
                            if_keyword open_brkt identifier op
                            integer_literal close_brkt
                        </code>
                    </li>
                </ul>
                <br />
                The lexeme types (if_keyword, integer_literal, ...) can be
                seen as the symbols of a higher language, the <b>source
                language</b> itself. Unfortunatelly, the source
                language is mostly going to be more complicated
                than regular languages. Most programming languages
                nowadays (like C and Java) belong to a class known
                as <b>context-free language</b>, a larger class
                that regular languages class is a proper subset of.
                You can see the C language
                as a context-free language whose symbols are
                the lexeme types specified in ANSI C standard.
                <br />
                <br />
                The grammar of a context-free language is called
                a <b>context-free grammar</b> and it introduces
                a more advanced syntax for productions rules.
                The context-free grammar for C language
                is described in detail in ANSI C. Sadly, FSMs are
                not powerful enough to recognize context-free
                languages. The more advanced <b>push-down automaton</b>
                is rather used as the acceptor for context-free languages.
                <br />
                <br />
                <table class="figure">
                    <tr>
                        <td>
                            <img src="../img/chomsky.jpg" width="500px" />
                        </td>
                    </tr>
                    <tr>
                        <td>
                            The left side is Chomsky's hierachy for grammar types.
                            <br />
                            The right side is the hierarchy of automata based on their power.
                            <br />
                            The hidden side is the magical power that created this symmetry!
                        </td>
                    </tr>
                </table>
                <br />
                The smart CS student designs a program that is called
                <b>syntax analyser generator</b>. such a program
                takes as input the grammar of the <b>source language</b>
                and outputs another program, the <b>syntax analyser</b>.
                The input to the syntax analyser is simply the output
                of the lexical analyser! The output of syntax analyser
                is the grammar structure for the input. This output
                is what we call as a <b>parse tree</b>, and the syntax
                analyser is therefore a <b>parser</b>. That being said,
                the syntax analysis is the second phase of compilation.
                <br />
                <table class="figure">
                    <tr>
                        <td>
                            <img src="../img/lexparse.png" width="600px" />
                        </td>
                    </tr>
                    <tr>
                        <td>
                            The big picture up till now.
                        </td>
                    </tr>
                </table>
                <br />
                The next step is to improve our syntax analyser generator
                to accept blocks of rules/actions embedded between
                the lines of grammar description. The purpose of this
                embedded code is to check the <b>semantic meaning</b>
                of the source language input. For example, <b>type checking</b>
                is one of this major duties of the semantic analysis.
                The output of the syntax analyser then is going
                to be a hybrid <b>syntax and semantic analyser</b>. Semantic
                Analysis can be seen as the third phase of compilation.
                <br />
                <br />
                The last step is to extended the embedded code capabilities,
                so that this embedded code doesn't only check the semantic
                meaning and perform type checking, but also generates some
                output! In that case this output can be some <b>intermediate
                language</b>, such as
                <a href="https://en.wikipedia.org/wiki/Three-address_code"
                   target="blank">Three-Address Code</a>.
                This is called <b>intermediate code generation</b> and this
                is the fourth phase of the compiler.
                <br />
                <br />
                The afore-mentioned four phases constitute the <b>front-end</b>
                of the compiler. The collection of lexical analyser generator
                and syntax/semantic analyser generator are called
                <b>compiler compiler</b>. The CS student has just created
                a compile compiler, that accepts the description
                of programming language (lexeme structures and grammar) as
                input, and the output of the compiler compiler is
                simply a <b>front-end compiler</b> that compiles the
                source language into an intermediate language.
                <br />
                <br />
                The next step is to create the <b>back-end</b>
                for the compiler, which optimizes the intermediate
                code and translates it into <b>assembly language</b>.
                The optimization process can be left for a graduate-level
                course, however, the translation of intermediate
                code into assembly language is very STRAIGHT FORWARD.
                <br />
                <table class="figure">
                    <tr>
                        <td>
                            <img src="../img/phases.jpg" width="600px" />
                        </td>
                    </tr>
                    <tr>
                        <td>
                            The whole phases of compilation.
                        </td>
                    </tr>
                </table>
                <br />
                The collection of the tools that the CS student
                has designed in systems programming course (assembler,
                linker, loader, ...) and OS course (operating system
                kernel) and compilers course (compiler compiler) are
                a complete set of all what you need to learn about
                system software...
                from machine code to how a high-level programming language
                is translated.
            </li>
        </ul>
        <p>
            I know the poor engineering argument is coming: "and what
            do all these courses have to do with firmware and embedded
            systems programming?!" said the ignorant Computer Engineer.
            The point, that the poor can't see, is that these courses shape
            your mind in a way that helps you write super-clean code and gives
            you deep understanding of what you are doing with your embedded
            device or computer BIOS, for instance.
        </p>
        <p>
            And I have seen it many times in Valeo and other places.
            <b>Computer and Electrical Engineers are terrible at coding.</b>
            Whether the code is high level or low level, they do not
            know what they are doing. They do not understand what
            the compiler is doing, or the main concepts of the assembler's
            language. They don't know what is a linker, loader, macro processor,
            lexer, parser, etc. When they study Computer Architecture or
            Operating Systems, they study them at a CS department, and
            they tend to be so dumb compared to their CS-majored classmates.
        </p>
        <p>
            Computer Engineering graduates have never studied
            Data Structures, Algorithm Analysis,
            File Organization, and many other important courses.
            Their curriculum has no structure. Their main role is highly
            debatable and they will never have a deep understanding
            of a 'computer' and a 'computation' unless they erase all
            the damage caused to their brain due to studying Computer Engineering,
            and then study Computer Science from scratch.
        </p>
        <h2 class="subtitle">
            Engineers on Dating
        </h2>
        <table class="figure">
            <tr>
                <td>
                    <img src="../img/grindr.png" />
                </td>
            </tr>
            <tr>
                <td>
                    Enough said.
                </td>
            </tr>
        </table>
        <h2 class="subtitle">
            Conclusion
        </h2>
        <p>
            If you are considering to do your undergraduate studies in a computer-related
            field of study, I suggest you consider Computer Science. Computer Science gives
            you a very deep philosophical, mathematical, and logical understanding
            of what a computer and a computation are. Computer Engineering will narrow
            up your mind and you will miss a lot of interesting CS material.
        </p>
        <p>
            If you join a CS program, you can simply take courses in Embedded Systems,
            Modern Physics, Quantum Mechanics, Circuits, Electronics, and IC/VLSI Design
            if you are very interested. All other hardware-related courses are mostly
            offered by your CS school (Computer Organization, Computer Architecture,
            Digital Design, FPGA Labs, etc.)
        </p>
        <p>
            <b>
                It's a big mistake to believe that Computer Science is more
                software and Computer Engineering is more hardware. Computer
                Science is actually a branch of mathematics; and the
                knowledge of such a powerful mathematical field of study
                serves both software and hardware.
            </b>
            Computer Science is all about computations. And computation can be
            implemented by hardware or software. <b>Computer Science include the
            study of both implementations.</b> Most computer scientists must
            have studied Digital Logic and Computer Architecture before
            obtaining their degree in Computer Science. Many other aspects
            of Computer Science are not just about software itself, but also cover
            the theory and the mathematics behind Computer Science. This
            is why CS graduates are good programmers and good computer-hardware
            masters at the same time.
        </p>
        <table class="figure">
            <tr>
                <td>
                    <img src="../img/checklist.png" />
                </td>
            </tr>
            <tr>
                <td>
                    Sample checklist for Computer Science and Computer Engineering courses.
                </td>
            </tr>
        </table>
        <p>
            Furthermore,
            many CS majors actually do Modern Physics and Quantum Mechanics courses
            because they are interested in <b>Quantum Computing</b>. So, you are not
            doing something wrong by studying Modern Physics and Quantum Mechanics
            while you are a CS major. The Circuits course is a direct application
            for the mathematical tools you have already studied (differential equations
            to model the circuits first, then Laplace Transform and Frequency-Domain Analysis
            for RLC circuits, and/or Phasor-Domain Analysis for AC circuits).
        </p>
        <p>
            The study of the Electronics course shall
            introduce semiconductor elements in the circuit, and this results in a change
            to the analytical model of the circuit impedance to become non-linear. You will
            learn how to model diode, BJT, and MOSFET circuits; and how to construct
            signal ampilifiers, op-amps, TTL logic and CMOS logic using the transistor
            as a switch/ampilifier triode-like device.
            <b>
                And of course it is very easy for a CS guy to
                study all this materials because CS students are smart.
            </b>
        </p>
        <p>
            In contrast, if you go with the Computer Engineering path, you will have
            a heavy overload studying a lot of Electrical Engineering courses that
            you might not be interested in, and you will have limited time studying
            CS-related courses, so you will have to make sacrifices. Furthermore,
            you will study Operating Systems, Computer Architecture, and many other
            courses with Computer Science students, and you will feel very dumb when
            you attend the class with them because they know better than you. So you
            will have depression and hate yourself. Your coding skills are gonna be
            terrible.
        </p>
        <p>
            You will miss courses on Data Structures, Algorithm Analysis,
            Compilers, Theory of Computation, Artificial Intelligence, Mathematical
            Logic and Discrete Math, Statistical Methods for Computers, Numerical
            Analysis, Linear and Dynamic Programming, and many other interesting
            courses. After graduation, you will not master the computer as
            your CS counterparts. You will always have that awkward feeling that
            you can't see the big picture.
        </p>
        <table class="figure">
            <tr>
                <td>
                    <img src="../img/cegrad.jpg" />
                </td>
            </tr>
            <tr>
                <td>
                    A Computer Engineering graduate.
                </td>
            </tr>
        </table>
    </body>
</html>
