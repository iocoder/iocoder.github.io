<html>
    <head>
        <title>Ramses - CS vs. CE</title>
        <meta name="author" content="Ramses Nagib" />
        <meta name="viewport" content="width=1024" />
        <link rel="shortcut icon" type="image/png" href="/img/favicon.png" />
        <link rel="stylesheet" type="text/css" href="/css/article.css" />
        <base target="_blank" />
    </head>
    <body>
        <div class="header">
            <object data="/html/header.html" type="text/html">
            </object>
        </div>
        <div class="address">
            <object data="/html/address.html" type="text/html">
            </object>
        </div>
        <h1>Why Computer Scientists Beat Computer Engineers</h1>
        <h3>Feb 4th, 2018</h3>
        <p style="color: blue; text-align: center;">
            <b><i>/* This is a sarcastic article targeting my classmates
            in Engineering. Nothing of what is written here is serious or
            real! */</i></b>
        </p>
        <table>
            <tr>
                <td style="text-align: center; padding-right: 150px;">
                    <img src="../img/ceguy.jpg" width="300px" />
                </td>
                <td style="text-align: center;">
                    <img src="../img/csgirl.jpg" width="250px" />
                </td>
            </tr>
            <tr>
                <td style="text-align: center; padding-right: 150px;">
                    Computer engineer:
                    WOW it finally prints Hello World!
                    I am a genius!
                </td>
                <td style="text-align: center;">
                    A
                    Computer Scientist
                    from 1980s repairing her
                    Apple machine
                    in order to do her research in
                    Artificial Intelligence.
                </td>
            </tr>
        </table>
        <h2>Computer Scientisits are <span>geeks</span>,
            Computer Engineers are <span>wannabe geeks</span>
        </h2>
        <p>
            It is clear to see this simple fact in every
            CS
            school and every
            CE school.
            A typical
            CS student's computer
            usually has
            GNU/Linux
            or
            probably
            FreeBSD
            installed.
            They might even take it further and use other
            UNIX(-Like) systems.
            Now ask one of those
            Computer Engineering students
            to show you their laptop.
            The argument for Microsoft Windows is always ready:
            Proteus/Multisim/Autocad/Whatever
            doesn't
            work on Linux
            (Yes they
            don't
            know the correct name,
            which is
            GNU/Linux).
        </p>
        <table>
            <tr>
                <td style="text-align: center;">
                    <img src="../img/desktop.png" width="640px" />
                </td>
            </tr>
            <tr>
                <td style="text-align: center;">
                    My desktop at some point of time.
                </td>
            </tr>
        </table>
        <p>
        </p>
        <h2>Theoretical Computer Science reshapes your mind</h2>
        <p>
           The study of
           Theoretical Computer Science
           (TCS)
           is something that
           makes a big difference between a
           Scientist
           and a
           dumb Engineer.
           It is magic.
           A CS undergraduate student is expected to have courses in
           <a href="https://en.wikipedia.org/wiki/Discrete_mathematics">Discrete Mathematics</a>,
           <a href="https://en.wikipedia.org/wiki/Symbolic_logic">Symbolic Logic</a>,
           <a href="https://en.wikipedia.org/wiki/Switching_theory">Switching Circuit Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Logic_synthesis">Digital Logic</a>,
           <a href="https://en.wikipedia.org/wiki/Automata_theory">Automata Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Formal_language">Formal Languages Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Computability_theory">Computability Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory">Computational Complexity Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Information_theory">Information Theory</a>,
           <a href="https://en.wikipedia.org/wiki/Operating_systems">Operating Systems</a>,
           <a href="https://en.wikipedia.org/wiki/Artificial_intelligence">Artificial Intelligence</a>,
           <a href="https://en.wikipedia.org/wiki/Data_mining">Data Mining</a>,
           and
           <a href="https://en.wikipedia.org/wiki/Programming_language_theory">Programming Language Theory</a>.
           This nice collection of these topics really opens your mind.
           <b>You become smarter</b>.
           You get a deep understanding of
           <span>what a computation is</span>,
           and
           <span>what the limits of a computer are</span>.
           These two green points are actually what
           Computer Science
           tries to answer.
        </p>
        <table>
            <tr>
                <td style="text-align: center;">
                    <img src="../img/amused.jpg" width="500px" />
                </td>
            </tr>
            <tr>
                <td style="text-align: center;">
                    A CS student amused in her first Linear Algebra lecture.
                </td>
            </tr>
        </table>
        <p>
            Computer Engineers
            keep claiming that they are the ones who understand
            the difference between
            hardware
            and
            software,
            how
            hardware
            and
            software
            interact,
            and how to
            co-design
            systems that involve both
            software
            and
            hardware.
            <b>This is not true</b>.
            First of all,
            the study of
            <a href="https://en.wikipedia.org/wiki/Computer_architecture">Computer Architecture</a>,
            which is considered as the core field of
            Computer Engineering,
            first originated in
            CS schools,
            not
            Engineering schools!
        </p>
        <p>
            Modeling a
            Computer Processor
            and abstracting it into
            <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">Instruction Set Architecture</a>
            (ISA)
            is a pure CS method of abstracting computing machines into abstract
            automata!
            Even if we talk about
            <a href="https://en.wikipedia.org/wiki/Computer_organization">Computer Organization</a>
            and how to design the components of the machine,
            the copulative study of
            <a href="https://en.wikipedia.org/wiki/Switching_circuit_theory">Switching Circuit Theory</a>
            and
            <a href="https://en.wikipedia.org/wiki/Finite-state_machine">Finite Automata Theory</a>
            is purely Computer Science.
            I bet 99% of CS schools offer such courses.
        </p>

        <p>
            After you study the typical
            mathematical model
            of a
            Computer processor,
            which is basically a Finite State Machine,
            you are expected to connect the processor
            to a limited form of a
            Computer Memory,
            and abstract this design into a
            <a href="https://en.wikipedia.org/wiki/Pushdown_automaton">Push-down automaton</a>
            model,
            then you study
            <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing Machine</a>
            model with an infinite tape,
            and see how we can simulate any computer program in the world using a
            Universal Turing Machine.
            Hereby you start to recognize
            the theoretical power and limitations of the Computer you have designed,
            and then you go further by studying
            <a href="https://en.wikipedia.org/wiki/Computability">Computability</a>
            and
            <a href="https://en.wikipedia.org/wiki/Decidability_(logic)">Decidability</a>.
            You learn how to reduce
            Turing Machines
            into models that encorporate
            the concept of
            <a href="https://en.wikipedia.org/wiki/Processor_register">computer register</a>,
            like
            <a href="https://en.wikipedia.org/wiki/Register_machine">Register machines</a>
            and
            <a href="https://en.wikipedia.org/wiki/Random-access_machine">RAM machine</a>
            (Harvard Architecture!).
        </p>
        <table>
            <tr>
                <td align="right">
                    <img src="../img/qsort1.png" height="350px" />
                </td>
                <td align="left">
                    <img src="../img/qsort2.png" height="350px" />
                </td>
            </tr>
            <tr>
                <td colspan="2" style="text-align: center;">
                    One of the
                    Computational Complexity Theory
                    lectures at my school,
                    by Prof.
                    <a href="https://scholar.google.ca/citations?user=DlSX_XcAAAAJ&hl=en">Amr Elmasry</a>
                    <br />
                    (hand-written
                    by my colleague,
                    Hanan Ahmad).
                    <b>This is Computer Science</b>.
                </td>
            </tr>
        </table>
        <p>
            The poor
            Computer Engineering
            students generally really lack the connection
            between
            Digital Design/Computer Architecture
            and
            Theory of omputation.
            They just teach them that there is something called
            Finite State Machine,
            and it consists of circles and arrows!
            (LOL!)
            Then they blindly use them to create
            sequential Logic,
            and to design a
            Processor Control Unit,
            either
            hard-wired
            or
            programmable,
            as well as
            ALUs,
            Pipelines,
            Exceptions,
            and other structures.
            That's it.
            They claim they know where the
            hardware
            and
            software
            meet,
            but the reality is:
            they never know!
        </p>
        <p>
            And the reason why they do not know where they meet is
            simple:
            If they did study
            Computer Science,
            they would have known that any
            kind of logic that solves a computable problem
            (i.e,
            any Turing Machine)
            can be implemented using either
            software
            (i.e,
            those symbols on the tape of the
            Turing Machine!),
            or
            Hardware
            (any
            model of computation
            whose power is lower than or equal to
            Turing Machine,
            can be simulated by a
            Turing Machine!)
        </p>
        <table>
            <tr>
                <td style="text-align: center;">
                    <img src="../img/oncomp.png" width="600px" />
                </td>
            </tr>
            <tr>
                <td colspan="2" style="text-align: center;">
                    <a href="../pdf/oncomp.pdf">On Computable Numbers,
                    with an Application to the Entscheidungsproblem<a/>.
                    <br />
                    By
                    <a href="https://en.wikipedia.org/wiki/Alan_Turing">Alan Turing</a>,
                    1936.
                    This is the point of time when CS was born.
                    <br />
                    (Ignore everything you have seen on that
                     Enigma-focused
                     movie because it
                    <br />
                     has nothing to do with the real research
                     work done by the mathematician).
                </td>
            </tr>
        </table>
        <h2>Tell me more about low-level programming</h2>
        <p>
            Computer Engineers
            will claim everywhere that they are the masters of
            low-level programming.
            The reality is,
            they are rather the masters of
            <a href="https://en.wikipedia.org/wiki/Spaghetti_code">Spaghetti Programming.</a>
        </p>
        <p>
            When we started learning programming at university,
            it was an
            'Art'
            course,
            not Science.
            <b>PROGRAMMING IS AN ART</b>.
            Furthermore,
            the programming textbook that any computer scientist
            must have been exposed to at least once in their life is
            clearly called
            <b>'The Art of Computer Programming'</b>
            (TAOCP)
            by the mathematician
            <a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>.
            Guess what?
            The code samples in this
            CS-core
            book is in
            <a href="https://en.wikipedia.org/wiki/Assembly_language">Assembler Language</a>.
            I am not saying
            'CS-core'
            because of the main topic of the textbook
            (which is programming),
            but actually because of the content which basically encorporates
            <a href="https://en.wikipedia.org/wiki/Data_structure">Data Structures</a>
            and
            <a href="https://en.wikipedia.org/wiki/Algorithm">Algorithms</a>,
            i.e.
            topics where Engineers are very very poor.
        </p>
        <p>
            In any CS school, there are basic set of system-software-related courses that
            most CS majors must take:
        </p>
        <ul>
            <li>
                <b>Computer Organization</b>:
                <br />
                <br />
                The course name is misleading.
                It
                doesn't
                mean Computer Organization in the sense of
                'hardware microarchitecture,'
                but instead it is just an
                entry-level
                course to a more advanced course on Computer Architecture.
                In this course
                we've
                studied what an ISA is,
                the debatable difference between computer organization and
                computer architecture,
                <b>68K processor and its instruction set</b>,
                <b>sample 68K assembly-code programs</b>,
                how the assembled program is stored in RAM and executed by 68K,
                various I/O devices of the computer and system bus,
                serial and parallel communication protocols,
                computer memory:
                SRAM and DRAM,
                signals running between processor and memory,
                the hardware and software of the hard disk,
                the printer,
                computer screen and VGA adapter,
                keyboard and typewriters,
                etc...
            </li>
            <table>
                <tr>
                    <td style="text-align: center;">
                        <img src="../img/partial.png" width="800px" />
                    </td>
                </tr>
                <tr>
                    <td style="text-align: center;">
                        Partial address decoding example,
                        from
                        Principles of Computer Hardware,
                        Clements.
                    </td>
                </tr>
            </table>
            <br />
            <li>
                <b>Systems and Components Programming</b>:
                <br />
                <br />
                This course is core in many CS schools,
                while some other schools will offer it as a
                highly-recommended
                elective course.
                Students learn the theory of assembly language as a foundational
                <a href="https://en.wikipedia.org/wiki/Imperative_programming">imperative-class programming language</a>.
                You learn concepts like mnemonics,
                operand structures and addressing modes,
                directives,
                opcode vs extended mnemonics,
                code sections,
                and other interesting
                low-level
                programming details
                (studied in an academic environment).
                Next you learn how the assembler works,
                and
                <b>students shall design a two-pass assembler</b>.
                <br />
                <br />
                Next,
                you learn
                how linkers and loaders work,
                and
                <b>students shall design a
                   linker-loader
                   for the object code generated
                   by the assembler they have designed</b>.
                Also,
                you learn macros and macro processing,
                and
                <b>students shall then design a macro processor</b>.
                Finally,
                the students qill integrate all those tools
                in one
                <b>integrated development environment</b>
                where the user simply creates
                assembly-code
                modules,
                then the modules automatically get
                macro-processed,
                assembled,
                and
                linked!
            </li>
            <br />
            <table>
                <tr>
                    <td style="text-align: center;">
                        <img src="../img/gnuld.png" width="800px" />
                    </td>
                </tr>
                <tr>
                    <td style="text-align: center;">
                        GNU linker manual pages on my gay communist machine.
                    </td>
                </tr>
            </table>
            <br />
            <li>
                <b>Operating Systems</b>:
                <br />
                <br />
                A basic course of any
                (and absolutely any)
                Computer Science curriculum.
                In the
                afore-mentioned
                systems programming course you have designed
                a set of tools that translate the assembly program into static or relocatble
                object code ready to be loaded into memory,
                and you designed the loader program itself.
                Now is the time to learn how to manage
                several program contexts loaded in memory simultaneously.
                You will be introduced to the concepts of
                <b>process</b>,
                <b>thread</b>,
                <b>context switching</b>,
                <b>multiprogramming</b>,
                and
                <b>scheduling</b>.
                You will study synchronization techniques like
                <b>Semaphores</b>
                and
                <b>Monitors</b>.
                Next,
                <b>students design</b>
                (or complete the design of)
                <b>an OS that
                   does nothing but loads programs in memory and schedule
                   them for the processor</b>.
                <br />
                <br />
                Next,
                you learn how the operating system manages
                I/O devices
                and you will be introduced to concepts like
                <b>Device Drivers</b>,
                <b>Interrupt Requests</b>,
                <b>Kernel-Mode</b>
                and
                <b>User-Mode</b>
                execution.
                You have the option to embed all the drivers
                and modules into one concrete program
                (<b>Monolithic Kernel</b>)
                or to dynamically load and execute device drivers and modules in
                user-mode
                (<b>Microkernel</b>).
                <br />
                You will also be exposed to concepts like
                <b>Memory Protection</b>,
                <b>Memory Management</b>,
                and algorithms that allocate the memory
                dynamically for the running programs,
                like
                <b><a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">Buddy Algorithm</b></a>.
                <br />
                <br />
                Finally you study
                <b>file systems</b>
                and concepts like
                <b>inode-structures</b>
                vs.
                <b>FAT</b>
                and
                hard-disk
                sector-based
                buffering and scheduling.
                I bet every CS graduate knows what I am talking about here.
            </li>
            <br />
            <table>
                <tr>
                    <td style="text-align: center;">
                        <img src="../img/diningph.png" width="400px" />
                    </td>
                </tr>
                <tr>
                    <td style="text-align: center;">
                        Every CS major knows what this is.
                        From Operating Systems Internals and Design Principles,
                        Stallings.
                    </td>
                </tr>
            </table>
            <br />
            <li>
                <b>Programming Language Theory</b>:
                <br />
                <br />
                As a follow up to Systems Programming course,
                it is important to show our smart
                CS students that imperative programming is not everything!
                There are way many programming paradigms that they must be aware of.
                The two biggest classes for programming languages are called
                <b>Imperative Languages</b>
                and
                <b>Declarative Language</b>.
                In imperative languages,
                you describe the control flow of the program,
                while a declarative program focuses on the intention of the computation
                and the data flow,
                <b>without describing the control flow</b>.
                <br />
                <br />
                Under Imperative Languages class we find
                <b>procedural languages</b>,
                where a program is divided into a set of procedures that call
                each others.
                Concepts like
                <b>block</b>
                and
                <b>scope</b>
                differentiate the procedural languages from other
                imperative languages.
                Under Imperative Languages class we also find
                <b>modular languages</b>
                where a program is organized as a set of modules that interact
                with each other,
                and each module has an
                <b>interface</b>.
                <br />
                <br />
                Finally,
                we develop an interesting imperative subclass called
                <b>structured languages</b>,
                where the control flow consists
                of three basic elements:
                imperative sequence,
                if-conditioned block,
                and
                while-looped blocked.
                Any other structure
                (e.g. for loop)
                is simply reduced to these three basic blocks.
                <b>Object Oriented Programming</b>
                is usually taught in a separate academic course,
                however,
                in this course a CS student should be able to understand how
                different OOP concepts are from structured programming.
                <br />
                <br />
                In contrast to Imperative Programming,
                there is another huge class that is called
                Declarative Languages
                class.
                In declarative languages,
                you do not describe the control flow at all.
                Subclasses of major interest include
                <b>Logic Programming languages</b>
                (like Prolog),
                <b>Functional Programming languages</b>
                (everywhere,
                from
                Haskell
                to
                Python's
                Lambda Expressions!),
                and finally
                <b>Data-Flow languages</b>
                (VHDL and Verilog).
                Parallel programming is a direct application to declarative programming
                (where Ada language and its little child,
                 VHDL,
                 rock).
                <br />
                <br />
                The reason why I am mentioning this CS course is to
                <b>let the ignorant engineers know that they know nothing
                   about VHDL and Verilog</b>.
                Computer scientists can tell you how different
                HDLs are from other language classes,
                and how to express a computation using an HDL language
                vs.
                how it is done in imperative languages.
                Finally,
                we can show you the mathematical proof that
                the VHDL and Verilog are
                Turing-complete.
                You guys think that we do not do VHDL and Verilog.
                However,
                we actually know them better than you do!
                we actually designed them for you!
            </li>
            <br />
            <table>
                <tr>
                    <td style="text-align: center;">
                        <img src="../img/ada.jpg" width="300px" />
                    </td>
                </tr>
                <tr>
                    <td style="text-align: center;">
                        Ada Lovelace,
                        the first computer programmer in history.
                        <br />
                        The brilliant
                        Ada programming language
                        is named after her.
                    </td>
                </tr>
            </table>
            <br />
            <li>
                <b>Compilers</b>:
                <br />
                <br />
                Finally,
                you study the most advanced level of system software,
                Compilers.
                And the reason why I am saying
                'most advanced'
                is that you need to study the
                Theory of Computation
                and
                the afore-mentioned
                courses first.
                Compilers and Programming Language Translators
                course is ideally offered in the last year of a
                BSc. in Computer Science
                program.
                <br />
                <br />
                It is mind blowing how
                Formal Language Theory
                and
                Theory of Computation
                are just two different names for the same thing.
                Every model of computation has an equivalent subclass of
                <b>Recursively-Enumerable Languages</b>.
                A
                <b>Finite State Machine</b>
                is simply an acceptor that tells you whether the input
                word belongs to the language or not
                (that's
                why when you studied switching circuits and models of computation courses,
                you have been taught that an FSM tuple has a a set element called
                'Final States Set').
                <br />
                <br />
                A
                <b>language</b>
                (set of words)
                can be expressed using two models:
                <ol>
                    <li>
                        <b>Automaton</b>
                        (Acceptor),
                        from the Theory of Computation domain.
                        This is the program that tells us whether
                        a word belongs to the language or not
                        (The C compiler!);
                        and
                    </li>
                    <li>
                        <b>Grammar</b>
                        (Generator),
                        from Formal Language Theory domain.
                        This is the
                        recursive-generator
                        for all the words that belong to the language
                        (The C Standard!).
                    </li>
                </ol>
                <br />
                A
                <b>regular language</b>
                is a language that can be expressed by a
                <b>regular expression</b>.
                A regular expression is a mathematical
                structure that describes recursive application of
                <b>concatenation</b>,
                <b>alternation</b>,
                and
                <b>Kleen closure</b>
                operations on
                <b>empty sets</b>,
                <b>sets of empty strings</b>,
                or
                <b>sets of language symbols</b>.
                <b>Kleene Theorem</b>
                tells us that for every
                <b>Finite State Machine</b>
                automaton,
                there is a corresponding regular language that the automaton accepts
                (recognizes).
                Poor Computer Engineering students do not know that the
                <b>Sequence Detectors</b>
                that they designed in Digital Logic courses are another form of FSM
                (called Transducers).
                Similar to the fact that a finite state machine is an
                acceptor of a Regular Language,
                a
                <b>Regular Grammar</b>
                is a generator for a
                Regular Language.
                <br />
                <br />
                <table>
                    <tr>
                        <td style="text-align: center;">
                            <img src="../img/langs.png" width="800px" />
                        </td>
                    </tr>
                    <tr>
                        <td style="text-align: center;">
                            Language classes and their corresponding Grammars
                            (Generators)
                            and Automata
                            (Acceptors).
                        </td>
                    </tr>
                </table>
                <br />
                The main application for the study of Regular Languages is the
                <b>lexical analysis</b>
                phase of the compiler,
                which is the very first phase of compilation process.
                Every
                <b>Lexeme</b>
                class of the Programming Language
                constitues a Regular Language by itself.
                For instance,
                when Computer Engineers study CS 101,
                they are taught that a variable name should only consist of
                letters,
                numbers,
                and underscores,
                and it cannot start with numbers.
                Why?
                the poor engineers never know.
                On the other hand, a CS student would interpret
                this rule as follow:
                an
                <b>identifier</b>
                is a word that belongs to the Regular Language expressed
                by the following Regular Expression:
                <code>({a-z}|{A-Z}|{_}).({a-z}|{A-Z}|{0-9}|{_})*</code>
                <br />
                <br />
                The
                <b>Lexical Analyser</b>
                is no more than a collection of
                Acceptors
                for all kinds of
                Lexeme classes
                (Identifiers,
                <b>Literals</b>,
                <b>Keywords</b>,
                etc.)
                encorporated in the
                <b>source language</b>.
                The Lexical Analyser can be seen as a big
                FSM
                that consists of
                sub-FSMs
                for every Regular Language
                a Lexem class might encorporate.
                A CS student designs a
                <b>Lexical Analyser Generator</b>,
                a program that takes a set of
                (Lexeme Class name,
                corresponding Regular Expressions)
                ordered pairs as input,
                and generates the lexical analyser
                (i.e.
                the big FSM)
                as output
                (<b>Yeah, the output of this program is another program</b>).
                The lexical analyser
                (the output program itself)
                takes arbitrary text as input,
                and outputs the Lexical Structure of the text
                (the Lexemes that have been identified along with their types).
                <br />
                <br />
                <ul>
                    <li>
                        Example for input to Lexical Analyser Generator:
                        <br />
                        <code>
                            (open_brkt, {(})
                            <br />
                            (close_brkt, {)})
                            <br />
                            (if_keyword, {i}.{f})
                            <br />
                            (op, {<}|{>}|{=})
                            <br />
                            (identifier, ({a-z}|{A-Z}|{_}).({a-z}|{A-Z}|{0-9}|{_})*)
                            <br />
                            (integer_literal, {0-9}.{0-9}*.({L}|lambda))
                        </code>
                    </li>
                    <br />
                    <li>
                        The output of the Generator is another program, called,
                        for instance, <code>lexer.elf</code>.
                    </li>
                    <br />
                    <li>
                        Example for text input to <code>lexer.elf</code>:
                        <br />
                        <code>if (var123 = 5)</code>
                    </li>
                    <br />
                    <li>
                        The corresponding output of <code>lexer.elf</code>:
                        <br />
                        <code>
                            if_keyword open_brkt identifier op
                            integer_literal close_brkt
                        </code>
                    </li>
                </ul>
                <br />
                The Lexeme classes
                (if_keyword,
                integer_literal,
                ...)
                are then interpreted as the symbols of a higher language,
                the
                <b>source language</b>
                itself.
                The source language is generally more complicated
                than regular languages.
                Most programming Languages nowadays
                (like C and Java)
                belong to a higher class known as
                <b>Context-Free Languagse</b>,
                of which the Regular Languages class is a proper subset.
                You can think of the
                C Language
                as a
                Context-Free Language
                whose symbols are the lexeme types which are
                specified in the ANSI C standard.
                <br />
                <br />
                The grammar of a
                Context-Free Language
                is called a
                <b>Context-Free Grammar</b>
                and it introduces a more advanced syntax for productions rules.
                The
                Context-Free Grammar
                for C
                is described in detail in ANSI C.
                Sadly,
                FSMs
                are not powerful enough to recognize
                Context-Free Languages.
                The more advanced
                <b>Push-Down Automaton</b>
                model is rather used as the acceptor for
                Context-Free Languages.
                <br />
                <br />
                <table>
                    <tr>
                        <td style="text-align: center;">
                            <img src="../img/chomsky.jpg" width="500px" />
                        </td>
                    </tr>
                    <tr>
                        <td style="text-align: center;">
                            The left side is Chomsky's hierachy for grammar types.
                            <br />
                            The right side is the hierarchy of automata based on their power.
                            <br />
                            The hidden side is the magical power that created this symmetry!
                        </td>
                    </tr>
                </table>
                <br />
                The smart CS student designs a program that is called
                <b>Syntax Analyser Generator</b>.
                It is a program takes as input the grammar of the
                <b>source language</b>
                and outputs another program,
                the
                <b>syntax analyser</b>.
                The input to the Syntax Analyser is simply the output
                of the Lexical Analyser!
                The output of Syntax analyser
                is the grammar structure for the input.
                This output is what we call as a
                <b>Parse tree</b>,
                and the Syntax Analyser is therefore called a
                <b>Parser</b>.
                That being said,
                the Syntax Analysis process is typically the second phase
                of compilation.
                <br />
                <table>
                    <tr>
                        <td style="text-align: center;">
                            <img src="../img/lexparse.png" width="600px" />
                        </td>
                    </tr>
                    <tr>
                        <td style="text-align: center;">
                            The big picture up till now.
                        </td>
                    </tr>
                </table>
                <br />
                The next step is to improve our
                Syntax Analyser Generator
                to accept blocks of
                rules/actions
                embedded between the lines of grammar description.
                The purpose of this embedded code is to check the
                <b>semantic meaning</b>
                of the source language input.
                For example,
                <b>type checking</b>
                is one of this major duties of the semantic analysis.
                The output of the syntax analyser in that case is going
                to be a hybrid
                <b>Syntax and Semantic Analyser</b>.
                Semantic Analysis is typically the third phase of compilation.
                <br />
                <br />
                Finally, the last step is to extend the embedded code
                capabilities such that the code does not only check the semantic
                meaning and perform type checking,
                but also generates another language!
                In that case this language could be any
                <b>Intermediate Language</b>,
                such as
                <a href="https://en.wikipedia.org/wiki/Three-address_code">Three-Address Code</a>.
                This is called
                <b>Intermediate Code Generation</b> phase,
                and it is the fourth phase of the compiler.
                <br />
                <br />
                The afore-mentioned four phases constitute the
                <b>front-end</b>
                part of the compiler.
                The combination of Lexical Analyser Generator
                and Syntax/Semantic Analyser Generator
                are together called a
                <b>Compiler Compiler</b>.
                The CS student has just created a compiler compiler,
                which accepts the description of a programming language
                (lexeme types and grammar) as input,
                and outputs the
                <b>front-end compiler</b> itself,
                which can later on be used to compile the
                source language into the intermediate language.
                <br />
                <br />
                The final step is to create the
                <b>back-end</b>
                compiler,
                which optimizes the intermediate code and
                translates it into
                <b>Assembly Language</b>.
                The optimization process is usually taught in
                a graduate-level course, however,
                the translation of intermediate code into Assembly
                (with no optimization)
                is very STRAIGHT FORWARD.
                <br />
                <table>
                    <tr>
                        <td style="text-align: center;">
                            <img src="../img/phases.jpg" width="600px" />
                        </td>
                    </tr>
                    <tr>
                        <td style="text-align: center;">
                            All the phases of compilation.
                        </td>
                    </tr>
                </table>
                <br />
                The combination of the tools that the CS student
                has designed in an earlier Systems Programming course
                (Assembler, Linker, Loader, ...)
                along with OS course
                (Kernel)
                and Compilers course
                (Compiler Compiler, Front-end Compiler, Back-end Compiler)
                basically teach you all what you need to learn about
                System Software...
                Starting with
                Machine Code
                and
                ending with how a
                High-Level Programming Language
                gets translated.
            </li>
        </ul>
        <p>
            I know the poor engineering argument is coming:
            "and what do all these courses have to do with
            Firmware
            and
            Embedded Systems programming?!",
            said the ignorant Computer Engineer.
            The point,
            which the poor Engineer can't see,
            is that these courses shape your mind in a way that
            helps you write
            super-clean
            code,
            and gives you deep understanding of what you are doing
            with your
            Embedded Device
            or
            Computer BIOS,
            for instance.
        </p>
        <p>
            And I have seen it happening too often in Valeo and other places.
            <b>Computer and Electrical Engineers are terrible at coding.</b>
            Whether the code is high level or low level,
            they do not know what they are doing.
            They do not understand what the Compiler does under the hood,
            or the main concepts of the Assembler Language.
            They do not know what Linker, Loader, Macro Processor,
            Lexer, Parser, and other tools are.
            When they study
            Computer Architecture
            or
            Operating Systems,
            they usually take them at a CS department,
            and, as you know, they tend to be so dumb compared to their
            CS-majored
            classmates.
        </p>
        <p>
            Computer Engineering graduates have never cared about
            Data Structures,
            Algorithm Analysis,
            File Organization,
            and many other important topics.
            Their curriculum has no structure.
            Their outline is highly debatable and they will never have
            a deep understanding of 'Computers' and 'Computation'
            unless they erase all the damage caused to their brain due to
            studying Computer Engineering,
            then start a clear Computer Science course from scratch.
        </p>
        <h2>Engineers in dating</h2>
        <table>
            <tr>
                <td style="text-align: center;">
                    <img src="../img/grindr.png" />
                </td>
            </tr>
            <tr>
                <td style="text-align: center;">
                    Enough said.
                </td>
            </tr>
        </table>
        <h2>Conclusion</h2>
        <p>
            If you are considering to do your
            Undergraduate studies in a
            Computer-related
            field of study,
            I suggest you consider Computer Science.
            Computer Science gives you a very deep
            philosophical,
            mathematical,
            and
            logical
            understanding of what a computer and computation are.
            Computer Engineering will narrow down your mind and
            you will miss a lot of interesting CS material and fun.
        </p>
        <p>
            If you join a CS program,
            you can simply take courses in
            Embedded Systems,
            Modern Physics,
            Quantum Mechanics,
            Circuits,
            Electronics,
            and
            IC/VLSI Design
            if you are interested.
            All other
            hardware-related
            courses are mostly offered by your CS school
            (like
            Computer Organization,
            Computer Architecture,
            Digital Design,
            FPGA Labs,
            etc.)
        </p>
        <p>
            <b>
                It is a big mistake to believe that
                Computer Science
                is more about software and that
                Computer Engineering
                is more about hardware.
                Computer Science is
                in fact a branch of
                Mathematics;
                and the powerful knowledge of such a mathematical field of study
                serves both software and hardware sides.
            </b>
            Computer Science
            is all about
            Computation.
            And computation can be implemented either by hardware or software.
            <b>Computer Science education coves the study of both implementations</b>.
            Most
            Computer Scientists
            must have done courses in
            Digital Logic
            and
            Computer Architecture
            before obtaining their degree in
            Computer Science.
            Many other aspects of
            Computer Science
            are not only about software itself,
            but also cover the theory and the mathematics behind
            Computer Science.
            This is why
            CS graduates
            are good programmers and good
            computer-hardware
            masters at the same time.
        </p>
        <table>
            <tr>
                <td style="text-align: center;">
                    <img src="../img/checklist.png" />
                </td>
            </tr>
            <tr>
                <td style="text-align: center;">
                    Sample checklist for
                    Computer Science
                    and
                    Computer Engineering
                    courses.
                </td>
            </tr>
        </table>
        <p>
            Many CS majors actually do
            Modern Physics
            and
            Quantum Mechanics courses
            because they are interested in
            <b>Quantum Computing</b>.
            It's very common for CS majors to take
            Modern Physics
            and
            Quantum Mechanics
            courses from other departments.
            The Electric Circuits
            course is a direct application for the mathematical tools
            that you have already studied
            (differential equations
            to model the circuits first,
            then
            Laplace Transform
            and
            Frequency-Domain Analysis
            for RLC circuits,
            and/or
            Phasor-Domain Analysis
            for
            AC circuits).
        </p>
        <p>
            The
            Electronics
            course
            introduces semiconductor elements in such circuits,
            and this results in a change to the analytical model
            of the circuit
            Impedance
            which then becomes
            non-linear.
            You will learn how to model the
            Diode,
            BJT,
            and
            MOSFET
            circuits;
            and how to construct
            Signal Ampilifiers,
            Op-amps,
            TTL Logic
            and
            CMOS Logic
            using the transistor as a
            switch/ampilifier
            triode-like
            device.
            <b>
                And of course it is very easy for a CS guy to
                study all this materials because CS students are smart.
            </b>
        </p>
        <p>
            In contrast,
            if you go with the
            Computer Engineering
            path, you will have a great overhead because you will have to study
            a lot of
            Electrical Engineering
            courses that you might not be interested in,
            and you will have limited time studying
            CS-related
            courses.
            You will have to make big sacrifices.
            Furthermore,
            you will have to take
            Operating Systems,
            Computer Architecture,
            and many other CS courses from CS department,
            and you will feel very dumb when
            you attend the classes with native CS majors
            because they know better than what you do.
            As a result, you will have depression and will hate your choices.
            Your coding skills are also gonna be seen as terrible,
            compared to the CS dudes of the same class.
        </p>
        <p>
            You will miss courses on
            Data Structures,
            Algorithm Analysis,
            Compilers,
            Theory of Computation,
            Artificial Intelligence,
            Mathematical Logic,
            Discrete Math,
            Statistical Methods for Computers,
            Numerical Analysis,
            Linear and Dynamic Programming,
            and many other interesting stuff.
            After graduation,
            you will not be able to complete with CS grads in many areas.
            You will always have that awkward feeling of regretting your choices.
        </p>
        <table>
            <tr>
                <td style="text-align: center;">
                    <img src="../img/cegrad.jpg" />
                </td>
            </tr>
            <tr>
                <td style="text-align: center;">
                    A
                    Computer Engineering
                    graduate.
                </td>
            </tr>
        </table>
        <p>
            <br />
        </p>
        <div class="footer">
            <object data="/html/footer.html" type="text/html">
            </object>
        </div>
    </body>
</html>
